/*
 * Copyright (C) 2006 TopCoder Inc., All Rights Reserved.
 *
 * TCS UML Model - Collaborations Version 1.0
 *
 * @ MockClassifier.java
 */

package com.topcoder.uml.model.core;

import java.util.Collection;
import java.util.List;

import com.topcoder.uml.model.activitygraphs.ObjectFlowState;
import com.topcoder.uml.model.commonbehavior.instances.Instance;
import com.topcoder.uml.model.core.auxiliaryelements.Comment;
import com.topcoder.uml.model.core.auxiliaryelements.TemplateArgument;
import com.topcoder.uml.model.core.auxiliaryelements.TemplateParameter;
import com.topcoder.uml.model.core.dependencies.Dependency;
import com.topcoder.uml.model.core.extensionmechanisms.Stereotype;
import com.topcoder.uml.model.core.extensionmechanisms.TaggedValue;
import com.topcoder.uml.model.core.relationships.AssociationEnd;
import com.topcoder.uml.model.core.relationships.Generalization;
import com.topcoder.uml.model.datatypes.VisibilityKind;
import com.topcoder.uml.model.modelmanagement.ElementImport;
import com.topcoder.uml.model.statemachines.StateMachine;

/**
 * <p>Mocked for test.</p>
 *
 * @author yinzi
 * @version 1.0
 */
public class MockClassifier implements Classifier {
    /**
     * <p>
     * Sets the name of the current object.
     * </p>
     *
     * @param name
     *            the name to be set for this object.
     */
    public void setName(String name)
    {
        ;
    }

    /**
     * <p>
     * Gets the name of the current object.
     * </p>
     *
     * @return the name of this object.
     */
    public String getName()
    {
        return null;
    }

    /**
     * <p>
     * Sets the visibility of the current object.
     * </p>
     *
     * @param visibility
     *            the visibility to be set for this object.
     */
    public void setVisibility(VisibilityKind visibility)
    {
       ;
    }

    /**
     * <p>
     * Gets the visibility of the current object.
     * </p>
     *
     * @return the visibility of this object.
     */
    public VisibilityKind getVisibility()
    {
        return null;
    }

    /**
     * <p>
     * Sets if the current object is specification.
     * </p>
     *
     * @param isSpecification
     *            a boolean value stating if the current object is specification.
     */
    public void setSpecification(boolean isSpecification){;}

    /**
     * <p>
     * Gets a boolean value that is true if the current object is specification.
     * </p>
     *
     * @return <code>true</code> if the current object is specification, otherwise <code>false</code>.
     */
    public boolean isSpecification(){return false;}

    /**
     * <p>
     * Adds a stereo type to the collection of the current object.
     * </p>
     *
     * @param stereotype
     *            the stereo type to be added.
     * @throws IllegalArgumentException
     *             if <code>stereoType</code> is null.
     */
    public void addStereotype(Stereotype stereotype){;}

    /**
     * <p>
     * Removes a stereo type from the collection of the current object.
     * </p>
     *
     * @param stereotype
     *            the stereo type to be removed.
     * @throws IllegalArgumentException
     *             if <code>stereoType</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal, i.e. its collection
     *         contained the specified stereo type.
     */
    public boolean removeStereotype(Stereotype stereotype){return false;}

    /**
     * <p>
     * Removes all the objects of type "stereo type" from the collection of the current object.
     * </p>
     */
    public void clearStereotypes(){;}

    /**
     * <p>
     * Gets all the objects of type "stereo type" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>Stereotype</code> added to the collection of current object.
     */
    public Collection<Stereotype> getStereotypes(){return null;}

    /**
     * <p>
     * Checks if a stereo type is contained in the collection of the current object.
     * </p>
     *
     * @param stereotype
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>stereotype</code> is null.
     * @return <code>true</code> if <code>stereoType</code> is contained in the collection of the current object.
     */
    public boolean containsStereotype(Stereotype stereotype){return false;}

    /**
     * <p>
     * Returns the number of objects of type "stereo type" previously added to the collection of the current object.
     * </p>
     *
     * @return the quantity of objects of type <code>Stereotype</code> inserted in the collection of the current
     *         object.
     */
    public int countStereotypes(){return 0;}

    /**
     * <p>
     * Adds a tagged value to the collection of the current object.
     * </p>
     *
     * @param taggedValue
     *            the tagged value to be added.
     * @throws IllegalArgumentException
     *             if <code>taggedValue</code> is null.
     */
    public void addTaggedValue(TaggedValue taggedValue){;}

    /**
     * <p>
     * Removes a tagged value from the collection of the current object.
     * </p>
     *
     * @param taggedValue
     *            the tagged value to be removed.
     * @throws IllegalArgumentException
     *             if <code>taggedValue</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal, i.e. its collection
     *         contained the specified tagged value.
     */
    public boolean removeTaggedValue(TaggedValue taggedValue){return false;}

    /**
     * <p>
     * Removes all the objects of type "tagged value" from the collection of the current object.
     * </p>
     */
    public void clearTaggedValues(){;}

    /**
     * <p>
     * Gets all the objects of type "tagged value" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>TaggedValue</code> added to the collection of current object.
     */
    public Collection<TaggedValue> getTaggedValues(){return null;}

    /**
     * <p>
     * Checks if a tagged value is contained in the collection of the current object.
     * </p>
     *
     * @param taggedValue
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>taggedValue</code> is null.
     * @return <code>true</code> if <code>taggedValue</code> is contained in the collection of the current object.
     */
    public boolean containsTaggedValue(TaggedValue taggedValue){return false;}

    /**
     * <p>
     * Returns the number of objects of type "tagged value" previously added to the collection of the current object.
     * </p>
     *
     * @return the quantity of objects of type <code>TaggedValue</code> inserted in the collection of the current
     *         object.
     */
    public int countTaggedValues(){return 0;}

    /**
     * <p>
     * Adds a reference tag to the collection of the current object.
     * </p>
     *
     * @param referenceTag
     *            the reference tag to be added.
     * @throws IllegalArgumentException
     *             if <code>referenceTag</code> is null.
     */
    public void addReferenceTag(TaggedValue referenceTag){;}

    /**
     * <p>
     * Removes a reference tag from the collection of the current object.
     * </p>
     *
     * @param referenceTag
     *            the reference tag to be removed.
     * @throws IllegalArgumentException
     *             if <code>referenceTag</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeReferenceTag(TaggedValue referenceTag){return false;}

    /**
     * <p>
     * Removes all the objects of type "reference tag" from the collection of the current object.
     * </p>
     */
    public void clearReferenceTags(){;}

    /**
     * <p>
     * Gets all the objects of type "reference tag" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>TaggedValue</code> added to the collection of current object.
     */
    public Collection<TaggedValue> getReferenceTags(){return null;}

    /**
     * <p>
     * Checks if a reference tag is contained in the collection of the current object.
     * </p>
     *
     * @param referenceTag
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>referenceTag</code> is null.
     * @return <code>true</code> if <code>referenceTag</code> is contained in the collection of the current object.
     */
    public boolean containsReferenceTag(TaggedValue referenceTag){return false;}

    /**
     * <p>
     * Returns the number of objects of type "reference tag" previously added to the collection of the current object.
     * </p>
     *
     * @return the quantity of objects of type <code>TaggedValue</code> inserted in the collection of the current
     *         object.
     */
    public int countReferenceTags(){return 0;}

    /**
     * <p>
     * Sets the namespace of the current object.
     * </p>
     *
     * @param namespace
     *            the namespace to be set for this object.
     */
    public void setNamespace(Namespace namespace){;}

    /**
     * <p>
     * Gets the namespace of the current object.
     * </p>
     *
     * @return the namespace of this object.
     */
    public Namespace getNamespace(){return null;}

    /**
     * <p>
     * Adds a supplier dependency to the collection of the current object.
     * </p>
     *
     * @param supplierDependency
     *            the supplier dependency to be added.
     * @throws IllegalArgumentException
     *             if <code>supplierDependency</code> is null.
     */
    public void addSupplierDependency(Dependency supplierDependency){;}

    /**
     * <p>
     * Removes a supplier dependency from the collection of the current object.
     * </p>
     *
     * @param supplierDependency
     *            the supplier dependency to be removed.
     * @throws IllegalArgumentException
     *             if <code>supplierDependency</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeSupplierDependency(Dependency supplierDependency){return false;}

    /**
     * <p>
     * Removes all the objects of type "supplier dependency" from the collection of the current object.
     * </p>
     */
    public void clearSupplierDependencies(){;}

    /**
     * <p>
     * Gets all the objects of type "supplier dependency" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>Dependency</code> added to the collection of current object.
     */
    public Collection<Dependency> getSupplierDependencies(){return null;}

    /**
     * <p>
     * Checks if a supplier dependency is contained in the collection of the current object.
     * </p>
     *
     * @param supplierDependency
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>supplierDependency</code> is null.
     * @return <code>true</code> if <code>supplierDependency</code> is contained in the collection of the current
     *         object.
     */
    public boolean containsSupplierDependency(Dependency supplierDependency){return false;}

    /**
     * <p>
     * Returns the number of objects of type "supplier dependency" previously added to the collection of the current
     * object.
     * </p>
     *
     * @return the quantity of objects of type <code>Dependency</code> inserted in the collection of the current
     *         object
     */
    public int countSupplierDependencies(){return 0;}

    /**
     * <p>
     * Adds a client dependency to the collection of the current object.
     * </p>
     *
     * @param clientDependency
     *            the client dependency to be added.
     * @throws IllegalArgumentException
     *             if <code>clientDependency</code> is null.
     */
    public void addClientDependency(Dependency clientDependency){;}

    /**
     * <p>
     * Removes a client dependency from the collection of the current object.
     * </p>
     *
     * @param clientDependency
     *            the client dependency to be removed.
     * @throws IllegalArgumentException
     *             if <code>clientDependency</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeClientDependency(Dependency clientDependency){return false;}

    /**
     * <p>
     * Removes all the objects of type "client dependency" from the collection of the current object.
     * </p>
     */
    public void clearClientDependencies(){;}

    /**
     * <p>
     * Gets all the objects of type "client dependency" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>Dependency</code> added to the collection of current object.
     */
    public Collection<Dependency> getClientDependencies(){return null;}

    /**
     * <p>
     * Checks if a client dependency is contained in the collection of the current object.
     * </p>
     *
     * @param clientDependency
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>clientDependency</code> is null.
     * @return <code>true</code> if <code>clientDependency</code> is contained in the collection of the current
     *         object.
     */
    public boolean containsClientDependency(Dependency clientDependency){return false;}

    /**
     * <p>
     * Returns the number of objects of type "client dependency" previously added to the collection of the current
     * object.
     * </p>
     *
     * @return the quantity of objects of type <code>Dependency</code> inserted in the collection of the current
     *         object.
     */
    public int countClientDependencies(){return 0;}

    /**
     * <p>
     * Adds a comment to the collection of the current object.
     * </p>
     *
     * @param comment
     *            the comment to be added.
     * @throws IllegalArgumentException
     *             if <code>comment</code> is null.
     */
    public void addComment(Comment comment){;}

    /**
     * <p>
     * Removes a comment from the collection of the current object.
     * </p>
     *
     * @param comment
     *            the comment to be removed.
     * @throws IllegalArgumentException
     *             if <code>comment</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeComment(Comment comment){return false;}

    /**
     * <p>
     * Removes all the objects of type "comment" from the collection of the current object.
     * </p>
     */
    public void clearComments(){;}

    /**
     * <p>
     * Gets all the objects of type "comment" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type <code>Comment</code>
     *         added to the collection of current object.
     */
    public Collection<Comment> getComments(){return null;}

    /**
     * <p>
     * Checks if a comment is contained in the collection of the current object.
     * </p>
     *
     * @param comment
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>comment</code> is null.
     * @return <code>true</code> if <code>comment</code> is contained in the collection of the current object.
     */
    public boolean containsComment(Comment comment){return false;}

    /**
     * <p>
     * Returns the number of objects of type "comment" previously added to the collection of the current object.
     * </p>
     *
     * @return the quantity of objects of type <code>Comment</code> inserted in the collection of the current object..
     */
    public int countComments(){return 0;}

    /**
     * <p>
     * Sets the parameter template of the current object.
     * </p>
     *
     * @param parameterTemplate
     *            the parameter template to be set for this object.
     */
    public void setParameterTemplate(TemplateParameter parameterTemplate){;}

    /**
     * <p>
     * Gets the parameter template of the current object.
     * </p>
     *
     * @return the parameter template of this object.
     */
    public TemplateParameter getParameterTemplate(){return null;}

    /**
     * <p>
     * Adds a default parameter to the collection of the current object.
     * </p>
     *
     * @param defaultParameter
     *            the default parameter to be added.
     * @throws IllegalArgumentException
     *             if <code>defaultParameter</code> is null..
     */
    public void addDefaultParameter(TemplateParameter defaultParameter){;}

    /**
     * <p>
     * Removes a default parameter from the collection of the current object.
     * </p>
     *
     * @param defaultParameter
     *            the default parameter to be removed
     * @throws IllegalArgumentException
     *             if <code>defaultParameter</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeDefaultParameter(TemplateParameter defaultParameter){return false;}

    /**
     * <p>
     * Removes all the objects of type "default parameter" from the collection of the current object.
     * </p>
     */
    public void clearDefaultParameters(){;}

    /**
     * <p>
     * Gets all the objects of type "default parameter" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>TemplateParameter</code> added to the collection of current object.
     */
    public Collection<TemplateParameter> getDefaultParameters(){return null;}

    /**
     * <p>
     * Checks if a default parameter is contained in the collection of the current object.
     * </p>
     *
     * @param defaultParameter
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>defaultParameter</code> is null.
     * @return <code>true</code> if <code>defaultParameter</code> is contained in the collection of the current
     *         object.
     */
    public boolean containsDefaultParameter(TemplateParameter defaultParameter){return false;}

    /**
     * <p>
     * Returns the number of objects of type "default parameter" previously added to the collection of the current
     * object.
     * </p>
     *
     * @return the quantity of objects of type <code>TemplateParameter</code> inserted in the collection of the
     *         current object.
     */
    public int countDefaultParameters(){return 0;}

    /**
     * <p>
     * Adds a template parameter at the end of the ordered collection of the current object.
     * </p>
     *
     * @param templateParameter
     *            the template parameter to be added.
     * @throws IllegalArgumentException
     *             if <code>templateParameter</code> is null.
     */
    public void addTemplateParameter(TemplateParameter templateParameter){;}

    /**
     * <p>
     * Adds a template parameter at specified index of the ordered collection of the current object.
     * </p>
     *
     * @param index
     *            the index at which to add
     * @param templateParameter
     *            the template parameter to be added.
     * @throws IllegalArgumentException
     *             if <code>templateParameter</code> is null.
     * @throws IndexOutOfBoundsException
     *             if <code>index</code> is &lt{;} 0 or gt{;} templateParameters.size().
     */
    public void addTemplateParameter(int index, TemplateParameter templateParameter){;}

    /**
     * <p>
     * Sets the template parameter at specified index of the ordered collection of the current object.
     * </p>
     *
     * @param index
     *            index of element to replace.
     * @param templateParameter
     *            the template parameter to be added.
     * @throws IllegalArgumentException
     *             if <code>templateParameter</code> is null.
     * @throws IndexOutOfBoundsException
     *             if <code>index</code> is &lt{;} 0 or gt{;}= templateParameters.size().
     */
    public void setTemplateParameter(int index, TemplateParameter templateParameter){;}

    /**
     * <p>
     * Removes (and fetches) the template parameter at specified index from the ordered collection of the current
     * object.
     * </p>
     *
     * @param index
     *            the index of the template parameter to be removed.
     * @throws IndexOutOfBoundsException
     *             if <code>index</code> is is &lt{;} 0 or gt{;}= templateParameters.size().
     * @return the removed object of type <code>TemplateParameter</code>.
     */
    public TemplateParameter removeTemplateParameter(int index){return null;}

    /**
     * <p>
     * Removes a template parameter from the ordered collection of the current object.
     * </p>
     *
     * @param templateParameter
     *            the template parameter to be removed.
     * @throws IllegalArgumentException
     *             if <code>templateParameter</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeTemplateParameter(TemplateParameter templateParameter){return false;}

    /**
     * <p>
     * Removes all the objects of type "template parameter" from the ordered collection of the current object.
     * </p>
     */
    public void clearTemplateParameters(){;}

    /**
     * <p>
     * Gets all the objects of type "template parameter" previously added to the ordered collection of the current
     * object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned list do not change the state of current object (i.e.
     * the returned list is a copy of the internal one of the current object). However, if an element contained in it is
     * modified, the state of the current object is modified accordingly (i.e. the internal and the returned lists share
     * references to the same objects).
     * </p>
     *
     * @return a <code>java.util.List</code> instance, containing all the objects of type
     *         <code>TemplateParameter</code> added to the collection of current object.
     */
    public List<TemplateParameter> getTemplateParameters(){return null;}

    /**
     * <p>
     * Checks if a template parameter is contained in the ordered collection of the current object.
     * </p>
     *
     * @param templateParameter
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>templateParameter</code> is null.
     * @return <code>true</code> if <code>templateParameter</code> is contained in the collection of the current
     *         object.
     */
    public boolean containsTemplateParameter(TemplateParameter templateParameter){return false;}

    /**
     * <p>
     * Gets the index of the specified template parameter in the ordered collection of the current object, or -1 if such
     * a collection doesn't contain it.
     * </p>
     *
     * @param templateParameter
     *            the desired element.
     * @throws IllegalArgumentException
     *             if <code>templateParameter</code> is null.
     * @return the index of the specified <code>TemplateParameter</code> in the ordered collection of the current
     *         object, or -1 if such a collection doesn't contain it.
     */
    public int indexOfTemplateParameter(TemplateParameter templateParameter){return 0;}

    /**
     * <p>
     * Returns the number of objects of type "template parameter" previously added to the ordered collection of the
     * current object.
     * </p>
     *
     * @return the quantity of objects of type <code>TemplateParameter</code> inserted in the ordered collection of
     *         the current object.
     */
    public int countTemplateParameters(){return 0;}

    /**
     * <p>
     * Adds a template argument to the collection of the current object.
     * </p>
     *
     * @param templateArgument
     *            the template argument to be added.
     * @throws IllegalArgumentException
     *             if <code>templateArgument</code> is null.
     */
    public void addTemplateArgument(TemplateArgument templateArgument){;}

    /**
     * <p>
     * Removes a template argument from the collection of the current object.
     * </p>
     *
     * @param templateArgument
     *            the template argument to be removed.
     * @throws IllegalArgumentException
     *             if <code>templateArgument</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeTemplateArgument(TemplateArgument templateArgument){return false;}

    /**
     * <p>
     * Removes all the objects of type "template argument" from the collection of the current object.
     * </p>
     */
    public void clearTemplateArguments(){;}

    /**
     * <p>
     * Gets all the objects of type "template argument" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>TemplateArgument</code> added to the collection of current object.
     */
    public Collection<TemplateArgument> getTemplateArguments(){return null;}

    /**
     * <p>
     * Checks if a template argument is contained in the collection of the current object.
     * </p>
     *
     * @param templateArgument
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>templateArgument</code> is null.
     * @return <code>true</code> if <code>templateArgument</code> is contained in the collection of the current
     *         object.
     */
    public boolean containsTemplateArgument(TemplateArgument templateArgument){return false;}

    /**
     * <p>
     * Returns the number of objects of type "template argument" previously added to the collection of the current
     * object.
     * </p>
     *
     * @return the quantity of objects of type <code>TemplateArgument</code> inserted in the collection of the current
     *         object.
     */
    public int countTemplateArguments(){return 0;}

    /**
     * <p>
     * Adds a element import to the collection of the current object.
     * </p>
     *
     * @param elementImport
     *            the element import to be added.
     * @throws IllegalArgumentException
     *             if <code>elementImport</code> is null.
     */
    public void addElementImport(ElementImport elementImport){;}

    /**
     * <p>
     * Removes a element import from the collection of the current object.
     * </p>
     *
     * @param elementImport
     *            the element import to be removed.
     * @throws IllegalArgumentException
     *             if <code>elementImport</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeElementImport(ElementImport elementImport){return false;}

    /**
     * <p>
     * Removes all the objects of type "element import" from the collection of the current object.
     * </p>
     */
    public void clearElementImports(){;}

    /**
     * <p>
     * Gets all the objects of type "element import" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>ElementImport</code> added to the collection of current object.
     */
    public Collection<ElementImport> getElementImports(){return null;}

    /**
     * <p>
     * Checks if a element import is contained in the collection of the current object.
     * </p>
     *
     * @param elementImport
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>elementImport</code> is null.
     * @return <code>true</code> if <code>elementImport</code> is contained in the collection of the current object.
     */
    public boolean containsElementImport(ElementImport elementImport){return false;}

    /**
     * <p>
     * Returns the number of objects of type "element import" previously added to the collection of the current object.
     * </p>
     *
     * @return the quantity of objects of type <code>ElementImport</code> inserted in the collection of the current
     *         object.
     */
    public int countElementImports(){return 0;}

    /**
     * <p>
     * Adds a behavior to the collection of the current object.
     * </p>
     *
     * @param behavior
     *            the behavior to be added.
     * @throws IllegalArgumentException
     *             if <code>behavior</code> is null.
     */
    public void addBehavior(StateMachine behavior){;}

    /**
     * <p>
     * Removes a behavior from the collection of the current object.
     * </p>
     *
     * @param behavior
     *            the behavior to be removed.
     * @throws IllegalArgumentException
     *             if <code>behavior</code> is null.
     * @return <code>true</code> if the current object state changed because of the removal.
     */
    public boolean removeBehavior(StateMachine behavior){return false;}

    /**
     * <p>
     * Removes all the objects of type "behavior" from the collection of the current object.
     * </p>
     */
    public void clearBehaviors(){;}

    /**
     * <p>
     * Gets all the objects of type "behavior" previously added to the collection of the current object.
     * </p>
     * <p>
     * Additions and removals of elements to and from the returned collection do not change the state of current object
     * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
     * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
     * returned collections share references to the same objects).
     * </p>
     *
     * @return a <code>java.util.Collection</code> instance, containing all the objects of type
     *         <code>StateMachine</code> added to the collection of current object.
     */
    public Collection<StateMachine> getBehaviors(){return null;}

    /**
     * <p>
     * Checks if a behavior is contained in the collection of the current object.
     * </p>
     *
     * @param behavior
     *            the element to be tested.
     * @throws IllegalArgumentException
     *             if <code>behavior</code> is null.
     * @return <code>true</code> if <code>behavior</code> is contained in the collection of the current object.
     */
    public boolean containsBehavior(StateMachine behavior){return false;}

    /**
     * <p>
     * Returns the number of objects of type "behavior" previously added to the collection of the current object.
     * </p>
     *
     * @return the quantity of objects of type <code>StateMachine</code> inserted in the collection of the current
     *         object
     */
    public int countBehaviors(){return 0;}
    //
    /**
    * <p>
    * Adds a feature at the end of the ordered collection of the current object.
    * </p>
    *
    * @param feature
    *            the feature to be added.
    * @throws IllegalArgumentException
    *             if <code>feature</code> is null.
    */
   public void addFeature(Feature feature){;}

   /**
    * <p>
    * Adds a feature at specified index of the ordered collection of the current object.
    * </p>
    *
    * @param index
    *            index at which the specified element is to be added.
    * @param feature
    *            the feature to be added.
    * @throws IllegalArgumentException
    *             if <code>feature</code> is null.
    * @throws IndexOutOfBoundsException
    *             if <code>index</code> is &lt{;} 0 or &gt{;} features.size.
    */
   public void addFeature(int index, Feature feature){;}

   /**
    * <p>
    * Sets the feature at specified index of the ordered collection of the current object.
    * </p>
    *
    * @param index
    *            index of feature to replace.
    * @param feature
    *            the feature to be added.
    * @throws IllegalArgumentException
    *             if <code>feature</code> is null.
    * @throws IndexOutOfBoundsException
    *             if <code>index</code> is &lt{;} 0 or &gt{;}= features.size.
    */
   public void setFeature(int index, Feature feature){;}

   /**
    * <p>
    * Removes (and fetches) the feature at specified index from the ordered collection of the current object.
    * </p>
    *
    * @param index
    *            the index of the feature to be removed.
    * @throws IndexOutOfBoundsException
    *             if <code>index</code> is &lt{;} 0 or &gt{;}= features.size.
    * @return the removed object of type <code>Feature</code>.
    */
   public Feature removeFeature(int index){return null;}

   /**
    * <p>
    * Removes a public Feature from the ordered collection of the current object.
    * </p>
    *
    * @param feature
    *            the public Feature to be removed.
    * @throws IllegalArgumentException
    *             if <code>feature</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removeFeature(Feature feature){return false;}

   /**
    * <p>
    * Removes all the objects of type "feature" from the ordered collection of the current object.
    * </p>
    */
   public void clearFeatures(){;}

   /**
    * <p>
    * Gets all the objects of type "feature" previously added to the ordered collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned list do not change the state of current object (i.e.
    * the returned list is a copy of the internal one of the current object). However, if an element contained in it is
    * modified, the state of the current object is modified accordingly (i.e. the internal and the returned lists share
    * references to the same objects).
    * </p>
    *
    * @return a <code>java.util.List</code> instance, containing all the objects of type <code>Feature</code> added
    *         to the collection of current object.
    */
   public List<Feature> getFeatures(){return null;}

   /**
    * <p>
    * Checks if a public Feature is contained in the ordered collection of the current object.
    * </p>
    *
    * @param feature
    *            the public Feature to be tested.
    * @throws IllegalArgumentException
    *             if <code>feature</code> is null.
    * @return <code>true</code> if <code>feature</code> is contained in the collection of the current object.
    */
   public boolean containsFeature(Feature feature){return false;}

   /**
    * <p>
    * Gets the index of the specified public Feature in the ordered collection of the current object, or -1 if such a
    * collection doesn't contain it.
    * </p>
    *
    * @param feature
    *            the desired feature.
    * @throws IllegalArgumentException
    *             if <code>feature</code> is null.
    * @return the index of the specified <code>Feature</code> in the ordered collection of the current object, or -1
    *         if such a collection doesn't contain it.
    */
   public int indexOfFeature(Feature feature){return 0;}

   /**
    * <p>
    * Returns the number of objects of type "feature" previously added to the ordered collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>Feature</code> inserted in the ordered collection of the current
    *         object.
    */
   public int countFeatures(){return 0;}

   /**
    * <p>
    * Adds a typed public Feature to the collection of the current object.
    * </p>
    *
    * @param typedFeature
    *            the typed public Feature to be added.
    * @throws IllegalArgumentException
    *             if <code>typedFeature</code> is null.
    */
   public void addTypedFeature(StructuralFeature typedFeature){;}

   /**
    * <p>
    * Removes a typed public Feature from the collection of the current object.
    * </p>
    *
    * @param typedFeature
    *            the typed public Feature to be removed.
    * @throws IllegalArgumentException
    *             if <code>typedFeature</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removeTypedFeature(StructuralFeature typedFeature){return false;}

   /**
    * <p>
    * Removes all the objects of type "typed feature" from the collection of the current object.
    * </p>
    */
   public void clearTypedFeatures(){;}

   /**
    * <p>
    * Gets all the objects of type "typed feature" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type
    *         <code>StructuralFeature</code> added to the collection of current object.
    */
   public Collection<StructuralFeature> getTypedFeatures(){return null;}

   /**
    * <p>
    * Checks if a typed public Feature is contained in the collection of the current object.
    * </p>
    *
    * @param typedFeature
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>typedFeature</code> is null.
    * @return <code>true</code> if <code>typedFeature</code> is contained in the collection of the current object.
    */
   public boolean containsTypedFeature(StructuralFeature typedFeature){return false;}

   /**
    * <p>
    * Returns the number of objects of type "typed feature" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>StructuralFeature</code> inserted in the collection of the
    *         current object.
    */
   public int countTypedFeatures(){return 0;}

   /**
    * <p>
    * Adds a typed parameter to the collection of the current object.
    * </p>
    *
    * @param typedParameter
    *            the typed parameter to be added.
    * @throws IllegalArgumentException
    *             if <code>typedParameter</code> is null.
    */
   public void addTypedParameter(Parameter typedParameter){;}

   /**
    * <p>
    * Removes a typed parameter from the collection of the current object.
    * </p>
    *
    * @param typedParameter
    *            the typed parameter to be removed.
    * @throws IllegalArgumentException
    *             if <code>typedParameter</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal, i.e. its collection
    *         contained the specified typed parameter.
    */
   public boolean removeTypedParameter(Parameter typedParameter){return false;}

   /**
    * <p>
    * Removes all the objects of type "typed parameter" from the collection of the current object.
    * </p>
    */
   public void clearTypedParameters(){;}

   /**
    * <p>
    * Gets all the objects of type "typed parameter" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type <code>Parameter</code>
    *         added to the collection of current object.
    */
   public Collection<Parameter> getTypedParameters(){return null;}

   /**
    * <p>
    * Checks if a typed parameter is contained in the collection of the current object.
    * </p>
    *
    * @param typedParameter
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>typedParameter</code> is null.
    * @return <code>true</code> if <code>typedParameter</code> is contained in the collection of the current
    *         object.
    */
   public boolean containsTypedParameter(Parameter typedParameter){return false;}

   /**
    * <p>
    * Returns the number of objects of type "typed parameter" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>Parameter</code> inserted in the collection of the current
    *         object.
    */
   public int countTypedParameters(){return 0;}

   /**
    * <p>
    * Adds a association to the collection of the current object.
    * </p>
    *
    * @param association
    *            the association to be added.
    * @throws IllegalArgumentException
    *             if <code>association</code> is null.
    */
   public void addAssociation(AssociationEnd association){;}

   /**
    * <p>
    * Removes a association from the collection of the current object.
    * </p>
    *
    * @param association
    *            the association to be removed.
    * @throws IllegalArgumentException
    *             if <code>association</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removeAssociation(AssociationEnd association){return false;}

   /**
    * <p>
    * Removes all the objects of type "association" from the collection of the current object.
    * </p>
    */
   public void clearAssociations(){;}

   /**
    * <p>
    * Gets all the objects of type "association" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type
    *         <code>AssociationEnd</code> added to the collection of current object.
    */
   public Collection<AssociationEnd> getAssociations(){return null;}

   /**
    * <p>
    * Checks if a association is contained in the collection of the current object.
    * </p>
    *
    * @param association
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>association</code> is null.
    * @return <code>true</code> if <code>association</code> is contained in the collection of the current object.
    */
   public boolean containsAssociation(AssociationEnd association){return false;}

   /**
    * <p>
    * Returns the number of objects of type "association" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>AssociationEnd</code> inserted in the collection of the current
    *         object.
    */
   public int countAssociations(){return 0;}

   /**
    * <p>
    * Adds a specified end to the collection of the current object.
    * </p>
    *
    * @param specifiedEnd
    *            the specified end to be added.
    * @throws IllegalArgumentException
    *             if <code>specifiedEnd</code> is null.
    */
   public void addSpecifiedEnd(AssociationEnd specifiedEnd){;}

   /**
    * <p>
    * Removes a specified end from the collection of the current object.
    * </p>
    *
    * @param specifiedEnd
    *            the specified end to be removed.
    * @throws IllegalArgumentException
    *             if <code>specifiedEnd</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removeSpecifiedEnd(AssociationEnd specifiedEnd){return false;}

   /**
    * <p>
    * Removes all the objects of type "specified end" from the collection of the current object.
    * </p>
    */
   public void clearSpecifiedEnds(){;}

   /**
    * <p>
    * Gets all the objects of type "specified end" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type
    *         <code>AssociationEnd</code> added to the collection of current object.
    */
   public Collection<AssociationEnd> getSpecifiedEnds(){return null;}

   /**
    * <p>
    * Checks if a specified end is contained in the collection of the current object.
    * </p>
    *
    * @param specifiedEnd
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>specifiedEnd</code> is null.
    * @return <code>true</code> if <code>specifiedEnd</code> is contained in the collection of the current object.
    */
   public boolean containsSpecifiedEnd(AssociationEnd specifiedEnd){return false;}

   /**
    * <p>
    * Returns the number of objects of type "specified end" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>AssociationEnd</code> inserted in the collection of the current
    *         object.
    */
   public int countSpecifiedEnds(){return 0;}

   /**
    * <p>
    * Adds a powertype range to the collection of the current object.
    * </p>
    *
    * @param powertypeRange
    *            the powertype range to be added.
    * @throws IllegalArgumentException
    *             if <code>powertypeRange</code> is null.
    */
   public void addPowertypeRange(Generalization powertypeRange){;}

   /**
    * <p>
    * Removes a powertype range from the collection of the current object.
    * </p>
    *
    * @param powertypeRange
    *            the powertype range to be removed.
    * @throws IllegalArgumentException
    *             if <code>powertypeRange</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removePowertypeRange(Generalization powertypeRange){return false;}

   /**
    * <p>
    * Removes all the objects of type "powertype range" from the collection of the current object.
    * </p>
    */
   public void clearPowertypeRanges(){;}

   /**
    * <p>
    * Gets all the objects of type "powertype range" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type
    *         <code>Generalization</code> added to the collection of current object.
    */
   public Collection<Generalization> getPowertypeRanges(){return null;}

   /**
    * <p>
    * Checks if a powertype range is contained in the collection of the current object.
    * </p>
    *
    * @param powertypeRange
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>powertypeRange</code> is null.
    * @return <code>true</code> if <code>powertypeRange</code> is contained in the collection of the current
    *         object.
    */
   public boolean containsPowertypeRange(Generalization powertypeRange){return false;}

   /**
    * <p>
    * Returns the number of objects of type "powertype range" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>Generalization</code> inserted in the collection of the current
    *         object.
    */
   public int countPowertypeRanges(){return 0;}

   /**
    * <p>
    * Adds a object flow state to the collection of the current object.
    * </p>
    *
    * @param objectFlowState
    *            the object flow state to be added.
    * @throws IllegalArgumentException
    *             if <code>objectFlowState</code> is null.
    */
   public void addObjectFlowState(ObjectFlowState objectFlowState){;}

   /**
    * <p>
    * Removes a object flow state from the collection of the current object.
    * </p>
    *
    * @param objectFlowState
    *            the object flow state to be removed.
    * @throws IllegalArgumentException
    *             if <code>objectFlowState</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removeObjectFlowState(ObjectFlowState objectFlowState){return false;}

   /**
    * <p>
    * Removes all the objects of type "object flow state" from the collection of the current object.
    * </p>
    */
   public void clearObjectFlowStates(){;}

   /**
    * <p>
    * Gets all the objects of type "object flow state" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type
    *         <code>ObjectFlowState</code> added to the collection of current object.
    */
   public Collection<ObjectFlowState> getObjectFlowStates(){return null;}

   /**
    * <p>
    * Checks if a object flow state is contained in the collection of the current object.
    * </p>
    *
    * @param objectFlowState
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>objectFlowState</code> is null.
    * @return <code>true</code> if <code>objectFlowState</code> is contained in the collection of the current
    *         object.
    */
   public boolean containsObjectFlowState(ObjectFlowState objectFlowState){return false;}

   /**
    * <p>
    * Returns the number of objects of type "object flow state" previously added to the collection of the current
    * object.
    * </p>
    *
    * @return the quantity of objects of type <code>ObjectFlowState</code> inserted in the collection of the current
    *         object.
    */
   public int countObjectFlowStates(){return 0;}

   /**
    * <p>
    * Adds a instance to the collection of the current object.
    * </p>
    *
    * @param instance
    *            the instance to be added.
    * @throws IllegalArgumentException
    *             if <code>instance</code> is null.
    */
   public void addInstance(Instance instance){;}

   /**
    * <p>
    * Removes a instance from the collection of the current object.
    * </p>
    *
    * @param instance
    *            the instance to be removed.
    * @throws IllegalArgumentException
    *             if <code>instance</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal, i.e. its collection
    *         contained the specified instance.
    */
   public boolean removeInstance(Instance instance){return false;}

   /**
    * <p>
    * Removes all the objects of type "instance" from the collection of the current object.
    * </p>
    */
   public void clearInstances(){;}

   /**
    * <p>
    * Gets all the objects of type "instance" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type <code>Instance</code>
    *         added to the collection of current object.
    */
   public Collection<Instance> getInstances(){return null;}

   /**
    * <p>
    * Checks if a instance is contained in the collection of the current object.
    * </p>
    *
    * @param instance
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>instance</code> is null.
    * @return <code>true</code> if <code>instance</code> is contained in the collection of the current object.
    */
   public boolean containsInstance(Instance instance){return false;}

   /**
    * <p>
    * Returns the number of objects of type "instance" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>Instance</code> inserted in the collection of the current object.
    */
   public int countInstances(){return 0;}
   
   // general
   /**
    * <p>
    * Sets if the current object is root.
    * </p>
    *
    * @param isRoot
    *            a boolean value stating if the current object is root.
    */
   public void setRoot(boolean isRoot){;}

   /**
    * <p>
    * Gets a boolean value that is true if the current object is root.
    * </p>
    *
    * @return <code>true</code> if the current object is root, otherwise <code>false</code>.
    */
   public boolean isRoot(){return false;}

   /**
    * <p>
    * Sets if the current object is leaf.
    * </p>
    *
    * @param isLeaf
    *            a boolean value stating if the current object is leaf.
    */
   public void setLeaf(boolean isLeaf){;}

   /**
    * <p>
    * Gets a boolean value that is true if the current object is leaf.
    * </p>
    *
    * @return <code>true</code> if the current object is leaf, otherwise <code>false</code>.
    */
   public boolean isLeaf(){return false;}

   /**
    * <p>
    * Sets if the current object is abstract.
    * </p>
    *
    * @param isAbstract
    *            a boolean value stating if the current object is abstract.
    */
   public void setAbstract(boolean isAbstract){;}

   /**
    * <p>
    * Gets a boolean value that is true if the current object is abstract.
    * </p>
    *
    * @return <code>true</code> if the current object is abstract, otherwise <code>false</code>.
    */
   public boolean isAbstract(){return false;}

   /**
    * <p>
    * Adds a generalization to the collection of the current object.
    * </p>
    *
    * @param generalization
    *            the generalization to be added.
    * @throws IllegalArgumentException
    *             if <code>generalization</code> is null.
    */
   public void addGeneralization(Generalization generalization){;}

   /**
    * <p>
    * Removes a generalization from the collection of the current object.
    * </p>
    *
    * @param generalization
    *            the generalization to be removed.
    * @throws IllegalArgumentException
    *             if <code>generalization</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removeGeneralization(Generalization generalization){return false;}

   /**
    * <p>
    * Removes all the objects of type "generalization" from the collection of the current object.
    * </p>
    */
   public void clearGeneralizations(){;}

   /**
    * <p>
    * Gets all the objects of type "generalization" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type
    *         <code>Generalization</code> added to the collection of current object.
    */
   public Collection<Generalization> getGeneralizations(){return null;}

   /**
    * <p>
    * Checks if a generalization is contained in the collection of the current object.
    * </p>
    *
    * @param generalization
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>generalization</code> is null.
    * @return <code>true</code> if <code>generalization</code> is contained in the collection of the current
    *         object.
    */
   public boolean containsGeneralization(Generalization generalization){return false;}

   /**
    * <p>
    * Returns the number of objects of type "generalization" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>Generalization</code> inserted in the collection of the current
    *         object.
    */
   public int countGeneralizations(){return 0;}

   /**
    * <p>
    * Adds a specialization to the collection of the current object.
    * </p>
    *
    * @param specialization
    *            the specialization to be added.
    * @throws IllegalArgumentException
    *             if <code>specialization</code> is null.
    */
   public void addSpecialization(Generalization specialization){;}

   /**
    * <p>
    * Removes a specialization from the collection of the current object.
    * </p>
    *
    * @param specialization
    *            the specialization to be removed.
    * @throws IllegalArgumentException
    *             if <code>specialization</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removeSpecialization(Generalization specialization){return false;}

   /**
    * <p>
    * Removes all the objects of type "specialization" from the collection of the current object.
    * </p>
    */
   public void clearSpecializations(){;}

   /**
    * <p>
    * Gets all the objects of type "specialization" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type
    *         <code>Generalization</code> added to the collection of current object.
    */
   public Collection<Generalization> getSpecializations(){return null;}

   /**
    * <p>
    * Checks if a specialization is contained in the collection of the current object.
    * </p>
    *
    * @param specialization
    *            the element to be tested.
    * @throws IllegalArgumentException
    *             if <code>specialization</code> is null.
    * @return <code>true</code> if <code>specialization</code> is contained in the collection of the current
    *         object.
    */
   public boolean containsSpecialization(Generalization specialization){return false;}

   /**
    * <p>
    * Returns the number of objects of type "specialization" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>Generalization</code> inserted in the collection of the current
    *         object.
    */
   public int countSpecializations(){return 0;}
   //namespace
   /**
    * <p>
    * Adds a owned element to the collection of the current object.
    * </p>
    *
    * @param ownedElement
    *            the owned element to be added.
    * @throws IllegalArgumentException
    *             if <code>ownedElement</code> is null.
    */
   public void addOwnedElement(ModelElement ownedElement){;}

   /**
    * <p>
    * Removes a owned element from the collection of the current object.
    * </p>
    *
    * @param ownedElement
    *            the owned element to be removed.
    * @throws IllegalArgumentException
    *             if <code>ownedElement</code> is null.
    * @return <code>true</code> if the current object state changed because of the removal.
    */
   public boolean removeOwnedElement(ModelElement ownedElement){return false;}

   /**
    * <p>
    * Removes all the objects of type "owned element" from the collection of the current object.
    * </p>
    */
   public void clearOwnedElements(){;}

   /**
    * <p>
    * Gets all the objects of type "owned element" previously added to the collection of the current object.
    * </p>
    * <p>
    * Additions and removals of elements to and from the returned collection do not change the state of current object
    * (i.e. the returned collection is a copy of the internal one of the current object). However, if an element
    * contained in it is modified, the state of the current object is modified accordingly (i.e. the internal and the
    * returned collections share references to the same objects).
    * </p>
    *
    * @return a <code>java.util.Collection</code> instance, containing all the objects of type
    *         <code>ModelElement</code> added to the collection of current object.
    */
   public Collection<ModelElement> getOwnedElements(){return null;}

   /**
    * <p>
    * Checks if a owned element is contained in the collection of the current object.
    * </p>
    *
    * @param ownedElement
    *            the ownedElement to be tested.
    * @throws IllegalArgumentException
    *             if <code>ownedElement</code> is null.
    * @return <code>true</code> if <code>ownedElement</code> is contained in the collection of the current object.
    */
   public boolean containsOwnedElement(ModelElement ownedElement){return false;}

   /**
    * <p>
    * Returns the number of objects of type "owned element" previously added to the collection of the current object.
    * </p>
    *
    * @return the quantity of objects of type <code>ModelElement</code> inserted in the collection of the current
    *         object.
    */
   public int countOwnedElements(){return 0;}
}
